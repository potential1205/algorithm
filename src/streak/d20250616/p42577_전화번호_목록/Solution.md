
## 풀이 복기
접두사를 비교하는 문제로 트라이가 가장 적합한 자료구조라고 판단했는데 구현 난이도는 높지 않았던 것 같다.

다만, 문자열을 어떤 순서로 저장하고 접두사를 확인하느냐에 따라 결과가 달라진다는 것을 유의해야한다.
왜냐하면 ["119559", "976", "119"] 와 같은 문자열 배열이 있다고 할 때 정렬되지 않은 순서로
트라이에 저장하고 접두사를 확인하게 되면 "119559"는 마지막 9 노드에 endOfWord가 true로 저장되므로
이후에 "119" 문자열이 접두사 탐색을 진행할 때 "119559"의 "119"를 접두사로 인식하지 못하기 때문이다.

## 다른 풀이 생각해보기
풀고나니 트라이를 사용하지 않고 더 간단한 방법들이 생각이 났다.
1. String.class의 startsWith() 를 활용하면 더 쉽게 풀 수 있었을 것 같다.

| 기준       | 현재 코드 (Trie)                          | 개선 코드 (정렬 + startsWith)       |
|------------|-------------------------------------------|-------------------------------------|
| 시간 복잡도 | O(N * M) (N: 전화번호 개수, M: 평균 길이) | O(N log N + N * M)                  |
| 구현 난이도 | 중 (직접 Trie 구현 필요)                  | 매우 쉬움                            |
| 실행 성능   | 좋음 (Trie는 최악에 강함)                 | 매우 좋음 (보통 입력에서는 훨씬 빠름) |
| 메모리 사용 | 높음 (Node 객체 수많이 생성)              | 낮음 (배열만 사용)                   |

2. 전체 문자열이 가지는 문자열 길이 경우의 수를 구한다음 문자열 길이만큼만 문자열을 비교하는 방법
3. 전체 문자열을 정렬한 후 인접한 문자열끼리만 접두사 관계를 확인하는 방법

## 마치며
사실 트라이를 기억할겸 일부러 사용하기도 했지만 알고리즘 풀이는 같은 문제도 여러 방법을 고민해보는게 도움이 많이 되는 것 같다.